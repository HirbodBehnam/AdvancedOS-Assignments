\smalltitle{سوال 1}
\\\noindent
نکته‌ای که در این سوال وجود دارد این است که هر
\lr{CPU}
باید جداگانه برای
\lr{core}های
خودش
\lr{TLB shootdown}ها
را ارسال کنید. این موضوع بدین معنی است که در صورتی بخواهیم یک
\lr{TLB shootdown}
ارسال کنیم،‌ هر کدام از 4
\lr{CPU}
باید یک
\lr{IPI}
برای
\lr{core}های خود ارسال کنند.
پس به ازای هر
\lr{TLB shootdown}
عملا
4
\lr{TLB shootdown IPI}
داریم.

حال دقت کنید که برای
\lr{malloc}
نیازی به
\lr{TLB shootdown}
نداریم. اما برای
\lr{free}
به احتمال خوبی نیاز به
\lr{TLB shootdown}
داریم. در ابتدا دقت کنید که حتی ممکن است که معلوم نباشد که چند
\lr{TLB shootdown}
نیاز است! فرض کنید که در این سیستم عامل از
\lr{huge page}
استفاده می‌کنیم که به ما صفحات یک مگابایتی می‌دهد. در این صورت هر
\lr{malloc}
یک یا نهایتا دو صفحه را درگیر می‌کند (صفحه دوم ممکن است برای ذخیره سازی اطلاعات فضای allocate شده استفاده شود.)
در این صورت صرفا برای هر دستور
\lr{free}،
یک یا نهایتا دو
\lr{page table \textbf{entry}}
باید به صورت مشخص از
\lr{TLB}
پاک شوند.
اما فرض کنید که صفحات چهار کلیوبایتی هستند. در این حالت بهتر است که یک
\lr{Complete TLB shootdown}
انجام دهیم که کل
\lr{TLB}
پاک شود. (چرا که تعداد صفحات زیاد است و احتمالا مقدار زیادی \lr{entry} در \lr{TLB} وجود دارد)

فرض کنیم که برای هر دستور
\lr{free}
نیاز داریم که کل
\lr{TLB}
را پاکسازی کنیم. (فرض کردیم که تعداد \lr{entry}ها زیاد است.)
در این صورت برای هر دستور
\lr{free}
نیاز به ۴
\lr{TLB shootdown IPI}
داریم. پس در کل
$1000000 \times 1000 \times 4$
\lr{TLB shootdown IPI}
داریم. دقت کنید که در کد داده شده در سوال مموری لیک نیز وجود دارد چرا که فقط هزارتا
از یک میلیون داده‌ای که
\lr{malloc}
کردیم را آزاد کردیم.

حال برسیم برای بهبود. اولین ایده‌ای که به ذهنمان می‌رسد این است که امنیت را فدای سرعت کنیم.
بدین منظور که تا زمان
\lr{malloc}
بعدی اصلا هیچ
\lr{TLB shootdown}ی
انجام ندهیم. با این کار در فاصله‌ی زمانی بین
\lr{free} و اولین \lr{malloc}
در صورتی که
\lr{entry}ای
در
\lr{TLB}
موجود باشد دسترسی به جایی
\lr{unallocated}
در حافظه پیدا می‌کنیم. دقت کنید که در این حالت نباید
\lr{page}ها
را به سیستم‌عامل برگردانیم. صرفا باید
\lr{page}ها
را برای خودمان علامتگذاری کنیم که بلا استفاده و
\lr{free}
هستند. در این حالت صرفا نیاز به
$1000000 \times 4$
\lr{TLB shootdown IPI}
داریم. دقت کنید که این کار حتی از لحاظ امنیت نیز آنچنان مشکل اساسی ندارد.
چرا که آن
\lr{page}ها
برای کار دیگری استفاده نمی‌شوند؛ صرفا به عنوان
\lr{free}
علامت گذاری شده‌اند. زمانی فقط
\lr{page}ها
را به صورت واقعی و درست حسابی
\lr{free}
می‌کنیم
(یعنی اینکه یک \lr{TLB shootdown} می‌فرستیم)
که
\lr{malloc}
کرده باشیم؛ چرا که در صورتی که
\lr{malloc}
کنیم، ممکن است که
\lr{frame}ای
که قبلا به عضو
$n$ام
اختصاص یافته بود، در حال حاضر به عضو
$m$ام
اختصاص یابد.

دقت کنید که در سوال بالا یک فرض خاص کردیم که در بعضی از زبان‌های
\lr{garbage collected}
مانند
\lr{Golang}
استفاده می‌شود:
در صورتی که حافظه‌ای را
\lr{free}
کنیم، این حافظه درجا به سیستم‌عامل بازگردانده نمی‌شود. بلکه صرفا
به عنوان حافظه‌ی خالی علامت گذاری می‌شود. (در خود برنامه) در صورتی که بخوایم حافظه‌ای را
\lr{allocate} 
کنیم، در ابتدا نگاه می‌کنیم که آیا مقداری از مموری را به عنوان خالی علامت گذاری کرده‌ایم
که بتوانیم آنرا صرفا به کاربر بدهیم؟ در این صورت همان مموری صرفا به عنوان مورد استفاده
علامتگذاری می‌شود و به کاربر داده می‌شود. همچنین در صورتی که نیاز باشد، مموری بیشتری از
سیستم‌عامل درخواست می‌کنیم.

